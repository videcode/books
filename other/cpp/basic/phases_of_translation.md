# Фази трансляції

##### Фаза 1
- Індивідуальні байти вихідного коду співставляються з символами базового набору. Частково, ОС-залежні індикатори кінця строки замінюються символом нової строки.  
  Символи базового набору складаються із 96 символів:  
    a) 5 символів пробілу (пробіл, горизонтальна табуляція, вертикальна табуляція, form feed, символ нової строки)  
	b) 10 цифрових символів з '0' до '9'  
	c) 52 літери з 'a' до 'z' і з 'A' до 'Z'  
	d) 29 символів пунктуації: _ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '  
- набір базових символів визначенно реалізацією С++11. Любий символ вихідного файлу, що не може бути співставленний із символом базового набору замінюється його [універсальним ім'ям символу](./universal_character_name.md) (єкранований з \u чи \U) чи деякою формою, що визначенна реалізацією, що обробляється еквівалентно.  
- [Послідовність триграфа](./alternative_operator_representations.md) замінюється відповідним односимвольним представленням (починаючи з С++17).
##### Фаза 2 
 1) Щоразу коли трапляється зворотний слеш в кінці строки (який слідує після 0 або більше символів пробілу, крім символу нового рядка (починаючи з C++23) ), то слеш та символ кінця строки видаляються, утворюющи з двух сирцевих рядків один логічний. Це однопрохідна операція. Рядок, що закінчується 2-а слешами та слідом пустий рядок, не об'єднуються в один. Якщо універсальне ім'я символу ( \uXXXX ) формується на цій фазі, то поведінка надалі невизначенна.  ґ
 2) Якщо не пустий серцевий файл не закінчується символом нового рядка після цього шагу, то поведінка на визначенна  (починаючи з С++11), додається символ кінця рядка (починаючи з С++11).
##### Фаза 3
 1) Сирцевий файл розкладається на:  
  - коментарії
  - послідовности символів пробілів
  - препроцесорних токенів: 
    - імена заголовків таких як ```c++ <iostream> ``` чи ```c++ "myfile.h" ```
	- [ідентифікатори](./identifiers/index.md)
	- препроцессорні числа
	- символи та строкові літерали, включаючи визначенні користувачем (з С++11)
	- оператори та пунктуатори (включаючи альтернативні токени), такі як +, <<= <%, ##, чи and
	- індивідуальні непробільні символи, що не попадають в жодну з категорій
 2) Будь-які перетворення здійсненні протягом фази 1 та 2 між початком і кінцем подвійної кавички будь-якого необробленного літерального рядка скасовуються. 
 3) Кожен коментар замінюється на один символ пробілу.  
Новоутворенні рядки зберігаються, і не вказоно чи послідовності пробільних символів (окрім кінця рядка) можуть бути згорнуті в одиночний пробільний символ.
##### Фаза 4
 1) Виконанний препроцессор
 2) Кожен файл представленний директивою #include проходить фази 1-4 рекурсивно.
 3) В кінці цієї фази, всі препроцессорні директиви видаляються з сирцевого коду.
##### Фаза 5
 1) Всі символи з символьних літералів та строкових літералів  конвертуються з сирцевої множини символів до виконуванної множини символів (котра може бути мультибайтною символьною множиною такою як UTF-8)
 2) Ескейп послідовності та універсальні імена символів та необробленні строкові літерали розкриваються та конвертуються до виконуванної множини символів. Якщо вказанний символ універсального імені символу не являється членом виконуванногої множини, результат визначенний реалізацією, але гарантується, що не буде null символом.
##### Фаза 6
 Сусідні строкові літерали об'єднуються
##### Фаза 7
 Компіляція: кожен препроцессорний токен конвертується в токен. Токени синтаксично та семантично аналізуються та транслюються як одиниця трансляції.
##### Фаза 8 
 Кожна одиниця трансляції перевіряється на можливість створення списку необхідних інстанціюваня шаблону, включаючи ті, що запитуються явним інстанціюванням.
##### Фаза 9
 Одиниці трансляції, одиниці інстанціювання та компоненти бібліотеки, необхідні щоб задовільнити зовнішні ссилки збираються в программній образ, котрий містить інформацію необхідну для виконання в його виконуванному середовищі.

###### Примітка
 Дейякі компілятори не реалізовують одиниці інстанціювання і просто компілюють кожне інстанціювання шаблону у фазі 7, сортують код в об'єктному файлі де вони явно чи неявно включені та потім лінкер згортає ці скомпільовані інстанції в одну у фазі 9.
